/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
/*
 * GameContext.java
 *
 * Created on Oct 10, 2010, 6:11:29 PM
 */
package org.openbase.planetsudo.view.menu

import org.openbase.jul.exception.CouldNotPerformException
import org.openbase.jul.exception.printer.ExceptionPrinter
import org.openbase.jul.visual.swing.image.ImageLoader
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.awt.EventQueue
import java.awt.Font
import javax.swing.*

/**
 *
 * @author [Divine Threepwood](mailto:divine@openbase.org)
 */
class GameContext : JFrame() {
    private val logger: Logger = LoggerFactory.getLogger(javaClass)

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private fun initComponents() {
        titleLabel = JLabel()
        jLabel2 = JLabel()

        defaultCloseOperation = DISPOSE_ON_CLOSE
        title = "Spielablauf"
        isAlwaysOnTop = true
        isResizable = false

        titleLabel!!.text = "Spielablauf"

        jLabel2!!.font = Font("Dialog", 0, 12) // NOI18N
        jLabel2!!.text =
            "<html>Zwei unterschiedliche Agententeams erobern einen für sie unbekannten Planeten. Ihre Mutterschiffe sind bereits gelandet und sie erkundschaften die Umgebung und sammeln in Konkurrenz zum gegnerischen Team über den Planeten zufällig verstreute Ressourcen ein, die sie anschließend zum Mutterschiff zurück bringen. Ziel des Spiels ist es, mit dem im Mutterschiff vorhandenen Treibstoff so viele Ressourcen wie möglich einzusammeln und zum Mutterschiff zu befördern. Die Agenten selber verbrauchen den Treibstoff und müssen diesen Regelmäßig beim Mutterschiff wieder auftanken. Andererseits bleiben sie auf dem Spielfeld ohne Funktionalität zurück. Zum Einsammeln der Ressourcen wird eine gewisse Zeit benötigt, zudem sind Agenten, die eine Ressource zum Mutterschiff transportieren, langsamer als normal. Entdeckt ein Agenten in seiner näheren Umgebung einen feindlichen Agenten, so ist es möglich mit diesem eine kriegerische Auseinandersetzung zu führen, bis der Treibstoff des Unterlegenen leer ist. Sollte der besiegte eine Resource getragen haben lässt er diese wieder fallen. Diese ist dann wieder zum Sammeln freigegeben. Sollte ein Agent das Mutterschiff der gegnerischen Mannschaft angreifen, so verliert dieses an Schildenergie. Geht die Schildenergie zuneige (unter 50%) so beginnt der Treibstoffvorrat des angegriffenen Mutterschiffs zu sinken. Je niedriger nun der Schild fällt, desto schneller sinkt der restliche Treibstoffvorrat des Mutterschiffs. Die Agenten des angegriffenen Mutterschiffs werden darüber benachrichtigt, dass ihr Mutterschiff angegriffen wird und können nun dementsprechend handeln. Das Spiel endet wenn der gesamte Treibstoff beider Teams verbraucht ist.</html>"

        val layout = GroupLayout(contentPane)
        contentPane.layout = layout
        layout.setHorizontalGroup(
            layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                .addGroup(
                    layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(
                            layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                                .addGroup(
                                    layout.createSequentialGroup()
                                        .addComponent(titleLabel)
                                        .addGap(0, 790, Short.MAX_VALUE.toInt()),
                                )
                                .addComponent(
                                    jLabel2,
                                    GroupLayout.Alignment.TRAILING,
                                    GroupLayout.PREFERRED_SIZE,
                                    0,
                                    Short.MAX_VALUE.toInt(),
                                ),
                        )
                        .addContainerGap(),
                ),
        )
        layout.setVerticalGroup(
            layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                .addGroup(
                    layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(titleLabel)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(
                            jLabel2,
                            GroupLayout.PREFERRED_SIZE,
                            GroupLayout.DEFAULT_SIZE,
                            GroupLayout.PREFERRED_SIZE,
                        )
                        .addContainerGap(428, Short.MAX_VALUE.toInt()),
                ),
        )

        pack()
    } // </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private var jLabel2: JLabel? = null
    private var titleLabel: JLabel? = null // End of variables declaration//GEN-END:variables

    /**
     * Creates new form GameContext
     */
    init {
        instance = this
        initComponents()
        try {
            titleLabel!!.icon = ImageIcon(ImageLoader.getInstance().loadImage("img/mothership.png"))
        } catch (ex: CouldNotPerformException) {
            ExceptionPrinter.printHistory(CouldNotPerformException("Could not display image", ex), logger)
        }
        setLocation(300, 300)
    }

    companion object {
        private var instance: GameContext? = null

        @Synchronized
        fun display() {
            if (instance == null) {
                EventQueue.invokeLater { GameContext().isVisible = true }
                Thread.sleep(500)
            } else {
                instance!!.isVisible = true
            }
        }

        /**
         * @param args the command line arguments
         */
        @JvmStatic
        fun main(args: Array<String>) {
            EventQueue.invokeLater { GameContext().isVisible = true }
        }
    }
}
